(ns sudoku.core
  (:use [clojure.math.numeric-tower]
        [clojure.java.shell]))

(defn max-var [size]
  "Outputs the largest variable for a given size"
  (+ (* size 100) (* size 10) size))
(def min-var 111)

(defn cell-to-var [i j k]
  "Converts a cell to an integer"
  (+ (* (inc i) 100 ) (* (inc j) 10) k))

(defn var-to-cell [var]
  "Converts an integer to cell representaiton"
  (conj '() (rem var 10) (dec (rem (quot var 10) 10)) (dec (quot var 100))))

(defn get-digit [puzzle i j]
  "Retreive value from puzzle by index"
  (. puzzle (get i j)))

(defn get-size [puzzle]
  "Returns the size of a puzzle"
  (. puzzle (size)))

(defn get-subsize [puzzle]
  "Returns the subsize of a puzzle"
  (. puzzle (subsize)))

(defn neg [i]
  "negate a variable"
  (* -1 i))

(defn read-puzzle [filename]
  "Read a .sdk file"
  (-> (SudokuReader. filename) (.readSudoku)))

(defn puzzle-to-vec [puzzle]
  "Converts puzzle to list format"
  (let [end (get-size puzzle)]
    (vec (for [i (range end)]
      (vec (for [j (range end)]
        (get-digit puzzle i j))))) ))

(defn cell-has-value-constraint [i j size]
  "Constraint enforcing that a cell has at least one value"
  (vector (vec (for [k (range size)]
    (cell-to-var i j (inc k))))))


(defn cell-is-unique-constraint [i j size]
  "Ensures that each cell can only have one value"
  (vec (remove nil? 
               (for [m (range size)
                     n (range size)]  
             (when (not= m n) 
               (vector (neg (cell-to-var i j (inc m)))  (neg (cell-to-var i j (inc n)))))))))

(defn cell-constraints [size]
  "Combines 'has-value' and 'is-unique' constraints"
  (vec (apply concat 
              (for [i (range size) 
                    j (range size)] 
                (into (cell-has-value-constraint i j size) (cell-is-unique-constraint i j size))))))

(defn row-constraints [size]
  "Ensures that each cell in a row has a different value"
  (vec (apply concat (for [k (range size)]
    (vec (for [i (range size)] 
        (vec (for [j (range size)]
            (cell-to-var i j k)))))))))

(defn col-constraints [size]
  "Ensures that each cell in a column has a different value"
  (vec (apply concat (for [k (range size)]
    (vec (for [j (range size)] 
        (vec (for [i (range size)]
            (cell-to-var i j k)))))))))


(defn inner-box-constraint [x y size subsize]
  "Returns a constraint for a 'box' (subpuzzle)"
  (vec (for [k (range size)]
    (vec (for [i (range (* x subsize) (+ subsize (* x subsize)))
          j (range (* y subsize) (+ subsize (* y subsize)))]
      (cell-to-var i j (inc k)))))))

(defn box-constraints [size subsize]
  "Generate all box constraints"
  (vec (apply concat (for [i (range (/ size subsize))
                           j (range (/ size subsize))]
                  (inner-box-constraint i j size subsize)))))

(defn puzzle-constraints [puzzle]
  "Load puzzle and get filled numbers"
  (vec (map vector (remove nil?  
     (for [i (range (get-size puzzle)) 
           j (range (get-size puzzle))] 
      (if (not= 0 (get-digit puzzle i j))
        (cell-to-var i j (dec (get-digit puzzle i j)))))))))


(defn all-constraints [puzzle]
  "Combine all constraints"
  (let [size    (get-size puzzle)
        subsize (get-subsize puzzle)]
    (reduce into [(puzzle-constraints puzzle)
                  (cell-constraints size)
                  (row-constraints size)
                  (box-constraints size subsize)])))

(defn dimacs-clause [clause]
  "Output a clause in diemacs format"
  (str (clojure.string/join " " clause) " 0"))

(defn dimacs-format [constraints size]
  "Convert to dimacs format"
  (let [header  
            (str "c Generated by cnf-sudoku\n"
                 "c Written by Andrew D. Wong\n"
                 "p cnf " (max-var size) " " (count constraints) "\n")
        strs (map dimacs-clause constraints)
        joined (clojure.string/join "\n" strs)] 
    (str header joined)))

(defn write-to-file [filename content]
  "Outputs content to filename"
  (with-open [wtr (clojure.java.io/writer filename)]
    (.write wtr content)))

(defn read-from-file [file]
  "Read file containing MiniSAT output"
  (map read-string  
       (re-seq #"[-\d.]+" (second (clojure.string/split (slurp file) #"\n")))))

(defn clean-input [coll size]
  "Clean the input removing unneedeed variables"
  (remove 
    #(or (= 0 (rem % 10)) (< % min-var) (> (abs %) (max-var size)))
  coll))

(defn create-sudoku [coll size]
  "Create sudoku object containing"
  (let [p (Sudoku. size)
        resolved-cells (map var-to-cell coll)]
    (doall (map (fn [coords] 
                  (. p (set (nth coords 0) (nth coords 1) (nth coords 2))))
                resolved-cells)) 
      p))

(defn -main 
  "Main method and driver for MiniSAT"
  ([file] ; given a filename
    (let [puzzle (read-puzzle file) ; read puzzle
          size (get-size puzzle) ; get size
          minisat "./minisat"
          cnf-file "puzzle.cnf"
          out-file "puzzle.out"]
      (.print puzzle) ; print initial puzzle
      (write-to-file cnf-file (dimacs-format (all-constraints puzzle) size)) ; Write to file
      (sh minisat cnf-file out-file) ; run minisat
      (shutdown-agents) ; Used to "close" futures from the sh command so the program doesn't hang
      (.print (create-sudoku (clean-input (read-from-file out-file) size) size)))) ; Output result
  ([] ; no command-line-args
    (-main "puzzles/wikipedia-example.sdk"))) ; run test file
